/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package BIL_481_Homework_1;

import java.util.Arrays;

import static spark.Spark.get;
import static spark.Spark.port;
import static spark.Spark.post;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;

import spark.ModelAndView;
import spark.template.mustache.MustacheTemplateEngine;



public class App {
    public String getGreeting() {
        return "Hello World!";
    }

    public static void main(String[] args) {
      //  System.out.println(new App().getGreeting());

        port(getHerokuAssignedPort());

        get("/", (req, res) -> "Hello, World");

        post("/compute", (req, res) -> {
          


            Map<String, String> map = new HashMap<String, String>();

            try{





          String input1 = req.queryParams("input1");
          java.util.Scanner sc1 = new java.util.Scanner(input1);
          sc1.useDelimiter("[;\r\n]+");
          java.util.ArrayList<Double> inputList1 = new java.util.ArrayList<>();
          while (sc1.hasNext())
          {
            double value = Double.parseDouble(sc1.next().replaceAll("\\s",""));
            inputList1.add(value);
          }
          sc1.close();
          System.out.println(inputList1);

          double[] input1_array = new double[inputList1.size()];

          for(int i=0;i<input1_array.length;i++)
            input1_array[i] = inputList1.get(i);


          String input2 = req.queryParams("input2");
          java.util.Scanner sc2 = new java.util.Scanner(input2);
          sc2.useDelimiter("[;\r\n]+");
          java.util.ArrayList<Double> inputList2 = new java.util.ArrayList<>();
          while (sc2.hasNext())
          {
            double value = Double.parseDouble(sc2.next().replaceAll("\\s",""));
            inputList2.add(value);
          }
          sc2.close();
          System.out.println(inputList2);

          double[] input2_array = new double[inputList2.size()];

          for(int i=0;i<input2_array.length;i++)
            input2_array[i] = inputList2.get(i);


          String input3 = req.queryParams("input3");
          java.util.Scanner sc3 = new java.util.Scanner(input3);
          sc3.useDelimiter("[;\r\n]+");
          java.util.ArrayList<Double> inputList3 = new java.util.ArrayList<>();
          while (sc3.hasNext())
          {
            double value = Double.parseDouble(sc3.next().replaceAll("\\s",""));
            inputList3.add(value);
          }
          sc3.close();
          System.out.println(inputList3);

          double[] input3_array = new double[inputList3.size()];

          for(int i=0;i<input3_array.length;i++)
            input3_array[i] = inputList3.get(i);


          String input4 = req.queryParams("input4").replaceAll("\\s","");
          int input4AsInt = Integer.parseInt(input4);

          Integer k = input4AsInt;


          double[] result_array = App.concatenateArraysAndReturnMeanAndKthOrderStatistics(input1_array, input2_array, input3_array, k);
          
          double mean =0;
          double kth =0;
          
          
          
          
        //  boolean result = true;

        /*
          String input2 = req.queryParams("input2").replaceAll("\\s","");
          int input2AsInt = Integer.parseInt(input2);
          
          boolean result = App.search(inputList1, input2AsInt);
          */


        //  Map<String, String> map = new HashMap<String, String>();
          if(result_array != null){

            mean = result_array[0];
            kth = result_array[1];

            map.put("mean", "mean is "+mean);
            map.put("kth", k + "'th order statistic is "+kth);
          }
          else{
            map.put("mean", "Parameters are incorrect.");
            map.put("kth", "Please try again with valid parameters. ");
          }

        }
        catch(Exception e){

            map.put("mean", "Parameters are incorrect.");
            map.put("kth", "Please try again with valid parameters. ");

        }




          return new ModelAndView(map, "compute.mustache");
        }, new MustacheTemplateEngine());


        get("/compute",
        (rq, rs) -> {
          Map<String, String> map = new HashMap<String, String>();
          map.put("mean", "Not computed yet!");
          return new ModelAndView(map, "compute.mustache");
        },
        new MustacheTemplateEngine());
}

static int getHerokuAssignedPort() {
    ProcessBuilder processBuilder = new ProcessBuilder();
    if (processBuilder.environment().get("PORT") != null) {
        return Integer.parseInt(processBuilder.environment().get("PORT"));
    }
    return 4567; //return default port if heroku-port isn't set (i.e. on localhost)
}



    


    public static double[] concatenateArraysAndReturnMeanAndKthOrderStatistics (double [] array1, double [] array2, double [] array3, Integer k){

        /*
            This method concatenates and sort given arrays(array1, array2 and array3) and returns a double array whose length is 2.
            First element of the result array is mean of this array.
            Second element of the result array is k'th order statistic of this larger array.
            If an error is occur or some parameters are invalid then this method returns null.

        */


        if(array1 == null || array2 == null || array3 == null || k == null ){ // check null parameters 
            return null;
        }

        if(k > (array1.length + array2.length + array3.length) || k <=0){ // k must be >=1 and <= sum of the all arrays lengths
            return null;
        }

        double[] big_array = new double[array1.length + array2.length + array3.length];

        double mean =0;

        for(int i=0;i<array1.length;i++){
            big_array[i] = array1[i];
            mean +=array1[i];
        }
        
        for(int i=0;i<array2.length;i++){
            big_array[array1.length + i] = array2[i];
            mean +=array2[i];
        }

        for(int i=0;i<array3.length;i++){
            big_array[array1.length + array2.length + i] = array3[i];
            mean += array3[i];
        }
        
        mean = mean / (array1.length + array2.length + array3.length);

        double k_statistic = 0;

        Arrays.sort(big_array);

        k_statistic = big_array[k-1];

        double[] result_array = new double[2];

        result_array[0] = mean;
        result_array[1] = k_statistic;



        return result_array;
    }





}
